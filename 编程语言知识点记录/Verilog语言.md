# Verilog笔记

## Verilog的主要特性

+ 可采用3种不同的方式进行设计建模
  + 行为级描述：使用过程化结构建模
  + 数据流描述：使用连续赋值语句建模
  + 结构化方式：使用门和模块例化语句
+ 两类数据类型：
  + 线网(`wire`) : 表示物理元件之间的连线
  + 寄存器(`reg`) : 表示抽象的数据存储元件
+ 能够描述层次设计
+ 原语可以是组合逻辑也可以是时序逻辑
+ 提供显示语言结构指定设计中的指定端口到端口的时延，以及路径时延和时序检查
+ 同一语言可用于生成模拟激励和指定测试的约束条件



## 主要应用---生成专用集成电路

+ 可编程逻辑器件
+ 半定制或全定制ASIC
+ 混合ASIC

## Verilog的设计方法

+ 采用自顶向下的设计方法

一般的设计流程:

1. 需求分析
2. 功能划分
3. 文本描述
4. 功能仿真
5. 逻辑综合
6. 布局布线
7. 时序仿真
8. FPGA/CPLD下载或 ASIC制造工艺生产



## 基础语法

+ 区分大小写
+ 格式自由，没有换行限制
+ 每个语句以分号结束

### 注释

`//`单行注释

`/* */`多行注释

### 标识符与关键字

**标识符**：任意一组字母，数字，`$`符号和`_`符号，标识符第一个字符必须是字母或下划线



## 数值表示

### 种类

+ 0：逻辑 0 和假
+ 1： 逻辑 1 和真
+ x或X ：未知 --> 信号可能是1，也可能是0
+ z或Z ： 高阻 --> 信号没有驱动时的逻辑结果

### 整数数值表示

合法的基数格式：十进制，十六进制，二进制，八进制

```verilog
4'b1011  //指明位宽为4，二进制
32'h3022_c0de   //指明位宽为32，16进制，下划线只是增强代码可读性，没有实际的作用
'o1024   //十进制，没有指明位宽
100     //默认为十进制
```



==负数表示==：

在最前面加上负号，如果指明位宽，则加在位宽之前



==实数表示==：

+ 十进制： `30.123 , 20.156 ...`
+ 科学计数法：`1.24e4 , 1_001e5 , 1E-8`



==字符串表示==：

字符串是由双引号包起来的字符队列 **字符串中不能包含回车符**

==Verilog 将字符串当做一系列的单字节 ASCII 字符队列==



```verilog
reg [0:14*8-1] str;
initial begin
    str = "www.zcc.com";
end
```



## 数据类型

### 线网

表示硬件单元之间的物理连线，由其连接的器件输出端连续驱动。

如果没有驱动单元连接到wire型变量，缺省值一般为`Z`

声明：

```verilog
wire interrupt;
wire flag1,flag2;
wire gnd = 1'b0;
```



### 寄存器

用来表示存储单元，会保持数据原有的值，直到被改写.

声明：

```verilog
reg clk_tmp;
reg falg1,flag2;
```



==寄存器不需要驱动源，也不一定需要时钟信号==

### 向量

当位宽大于`1`时，`wire`或`reg`可以声明为向量的形式

```verilog
reg [3:0]  counter;        //声明4bit位宽的寄存器
wire [32-1:0] gpio_data;   //声明32bit位宽的线网
wire [8:2] addr;           //声明7位宽的线网，位宽范围8：2
reg  [0:31] data;          //声明32bit位宽的寄存器，最高有效位为0
```



Verilog支持指定bit位后固定位宽的向量域选择访问

```verilog
[bit+:width]    //从起始bit位开始递增,位宽为width
[bit-:width]    //从起始bit位开始递减，位宽为width
```



对信号重新进行组合成新的向量时，需要使用大括号

```verilog
wire [31:0]   temp1,temp2;
assign temp1 = {byte1[0][7:0],data1[31:8]};    //数据拼接
assign temp2 = {32{1'b0}};    //赋值32位的数值0
```

### 整数，实数，时间寄存器变量



整数类型用关键字`integer`声明，声明时不用指明位宽，位宽和编译器有关，一般为32bit

==reg型变量为无符号数==

==integer型变量为有符号数==

```verilog
reg [31:0]   data;
reg [3:0]    byte1[7:0];
integer  j;
always@* begin
    for (j=0;j<3;j=j+1) begin
        byte1[j] = data[(j+1)*8-1:j*8];
        //把data[7:0]...data[31:24] 依次赋值给byte1[0][7:0]...[3][7:0]
    end
end
```



实数用关键字`real`来声明，可用十进制或科学计数法表示。 ==实数声明不能带有范围，默认值为0==

==如果将一个实数赋值给整数，只有整数部分会被保留==



Verilog使用特殊的时间寄存器time型变量，对仿真时间进行保存。==一般位宽为64bit==，可以通过系统函数`$time`获取当前仿真时间

```verilog
time    current_time;
initial begin
    #100 ;
    current_time = $time;
end
```

### 数组

==线网数组也可以用于连接实例模块的端口==

```verilog
integer          flag [7:0] ; //8个整数组成的数组
reg  [3:0]       counter [3:0] ; //由4个4bit计数器组成的数组
wire [7:0]       addr_bus [3:0] ; //由4个8bit wire型变量组成的数组
wire             data_bit[7:0][5:0] ; //声明1bit wire型变量的二维数组
reg [31:0]       data_4d[11:0][3:0][3:0][255:0] ; //声明4维的32bit数据变量数组
```



==向量是一个单独的元件，位宽为 n；数组由多个元件组成，其中每个元件的位宽为 n 或 1==



### 存储器

描述RAM或ROM的行为

```verilog
reg    membit[0:255];
reg [7:0]   mem[0:1023];     
mem[511] = 8'b0 ;
```



### 参数

参数表示常量，用关键字`parameter`声明，只能赋值一次

```verilog
parameter data_width = 10'd32;
parameter i = 1,j = 2,k = 3;
parameter mem_size = data_width * 10;
```

==通过实例化的方式，可以更改参数在模块中的值==

==局部参数用 localparam 来声明，其作用和用法与 parameter 相同，区别在于它的值不能被改变。所以当参数只在本模块中调用时，可用 localparam 来说明。==



### 字符串

==字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）==

==字符串不能多行书写，即字符串中不能包含回车符==

==如果寄存器变量的宽度大于字符串的大小，则使用 0 来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。==



## 表达式



### 表达式

由操作符和操作数组成，目的是根据操作符的意义得到一个计算结果

```verilog
a^b ;  
address[9:0] + 10'b1;
flag1 && falg2;
```



### 操作数

可以是任意的数据类型，只是某些特定的语法结构要求使用特定类型的操作数

```verilog
module test;
    
    //实数
    real a,b,c;
    c=a+b;
    
    //寄存器
    reg [3:0] cprmu_1,cprmu_2;
    always @(posedge clk)begin
        cprmu_2 = cprmu_1 ^cprmu_2;
    end
    
    //函数
    reg flag;
    flag = calculate_result(A,B);
    
    //非法
    reg [3:0] res;
    wire [3:0] temp;
    always@ (*)begin
        res = cprmu_2 - cprmu_1;
    end
endmodule
```



### 操作符

