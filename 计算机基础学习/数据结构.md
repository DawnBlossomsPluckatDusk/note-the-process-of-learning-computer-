# 数据结构

## 引言-术语介绍

### 数据

对客观事物的符号表示，是计算机输入的原料。例如：学生名单，一个人的信息

### 数据元素

是数据的基本单位，一个数据元素可由多个数据项组成，数据项是数据的不可分割的最小单位

### 数据对象

 性质相同的数据元素的集合，是数据的一个子集

### 数据结构

相互之间存在一种或多种特定关系的数据元素的集合(解释不唯一)---主要是指，数据元素之间的关系

数据结构的形式定义为：

```
Data_Structure = (D,S)
D是数据元素的有限集  ----数据集合
S是D上关系的有限集   ----数据元素之间的相互关系
```

数据结构的两种表示方法：

+ 顺序映像        ----顺序存储结构
+ 链式存储结构   ----链式存储结构

### 数据类型

一个值的集合和定义在这个集合上的操作，例如：整数集合上的加减乘除操作

两类数据类型：

+ 原子类型：不可拆分
+ 结构类型：由原子类型和结构类型组成

### 抽象数据类型(Abstract Data Type)

一个数学模型以及定义在该模型上的一组操作

一个含有抽象数据类型的软件通常应该包含：`定义`，`表示`和`实现`

抽象数据类型的三种分类：

+ 原子类型：不可分解的
+ 固定聚合类型：由确定数目的成分按某种结构组成
+ 可变聚合类型：由数目不确定的成分按某种结构组成

抽象数据类型的形式定义：

```
ADT=(D,S,P)
D-> 数据对象
S-> 数据之间的关系
P-> 数据集上的操作
```

#### 多形数据类型(Polymorphic data type)

+ 定义：其值的成分不确定的数据类型

## 线性表

### 线性表的类型定义

线性结构的特点：

+ 存在唯一的一个被称做"第一个"的数据元素
+ 存在唯一的一个被称做"最后一个"的数据元素
+ 除第一个之外，集合中的每个数据元素均只有一个前驱
+ 除最后一个之外，集合中的每个数据元素均只有一个后继

抽象数据类型线性表的定义：

```
ADT List{
	数据对象: D
	数据关系: R={<A(i-1),A(i)> | i=2,···,n}
	基本操作:
		InitList(&L)                     //构造一个空的线性表L
		DestroyList(&L)                  //销毁线性表L
		ClearList(&L)                    //将L重置为空表
		ListEmpty(L)                     //若L为空表，则返回true,否则返回false
		ListLength(L)                    //返回L中的数据元素个数
		GetElem(L,i,&e)                  //用e返回L中第i个数据元素的值
		LocateElem(L,e,compare())        //返回L中第一个与e满足关系compare的数据元素的位序，若不存在返回0
		PoriorElem(L,cur_e,&pre_e)       //若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败
		NextElem(L,cur_e,&next_e)        //若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败
		ListInsert(&L,i,e)               //在L中第i个位置之前插入新的数据元素e，L长度加1
		ListDelete(&L,i,&e)              //删除L的第i个数据元素，并用e返回其值，L的长度减1
		ListTraverse(L,visit())          //依次对L的每个数据元素调用visit，一旦visit失败，则操作失败
}
```



### 线性表的顺序表示和实现

线性表的顺序表示指的是用一组地址连续的存储单元依次存储单元依次存储线性表的数据元素

特点：

+ 对某个位置上的数据元素查找时间复杂度为O(1)
+ 对插入，删除某一位置上的数据元素时间复杂度为O(n)
+ 在物理和逻辑上都是连续的

存储结构如下：

```c
#define LIST_INY_SIZE  100  //线性表存储空间的初始分配量
#define LISTINCREMENT   10  //线性表存储空间的分配增量
typedef struct{
    ElemType *elem;  //存储空间基址(动态)
    ElemType List[LIST_INY_SIZE];    ///存储空间(静态)
    int length;      //当前长度
    int listsize;    //当前分配空间的存储容量
}SqList;
```



### 线性表的链式表示和实现

线性表的链式存储结构特点是用一组任意的存储单元存储线性表的数据元素

对于一个数据元素(结点)来说，它包含的信息有：

+ 存储的信息的域---数据域
+ 存储直接后继存储位置的域---指针域

n个结点链结成一个链表，即为线性表

指针域代表着数据元素之间的逻辑关系的映像

#### 线性链表

当链表中的每个结点都只包含一个指针域时，称为线性链表或单链表

整个链表的存取必须从头指针开始，链表中最后一个数据元素没有直接后继，故指针域为空(NULL)

在单链表的第一个结点之前附设一个结点，称为头节点，头节点的数据域可以不包含任何信息，也可以包含一些附加信息，例如：链表长度

存储结构:

```c
typedef struct LNode{
    ElemType data;
    struct LNode* next;
}LNode,*LinkList;
```

#### 循环链表

特点：链表的最后一个数据元素指向链表的第一个数据元素(不是头节点)

#### 双向链表

存储结构：

```c
typedef strcut DuLNode{
    ElemType data;
    struct DuLNode *prior;
    struct DuLNode *next;
}DuLNode,*DuLinkList;
```

相比于单链表，增加了一个指向前驱的指针，其余操作不变

### 总结

一个带头节点的线性链表类型定义如下：

```c
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}*Link,*Position;

typedef struct{
    Link head,tail;
    int len;
}LinkList;

Status MakeNode(Link &p,ElemType e);//分配由p指向的值为e的结点，并返回ok，否则返回error
void FreeNode(Link &p);//释放p所指向的结点
Status InitList(LinkList &L);//构造一个空的线性链表L
Status DestoryList(LinkList &L);//销毁线性链表
Status ClearList(LinkList &L);//将线性链表重置为空表，并释放该空间
Status InsFirst(Link h,Link s);//将s所指结点插入在第一个结点之前
Status DelFirst(Link h,Link &q);//删除链表的第一个结点并以q返回
Status Append(LinkList &L,Link s);//将指针s所指的一串结点链接在线性链表L的最后一个结点，并改变链表L的尾指针
Status Remove(LinkList &L,Lik &q);//删除线性链表L中的尾结点并以q返回，改变链表L的尾指针指向新的尾结点
Status InsBefore(LinkList &L,Link &p,Link s);//已知p指向线性链表L中的一个结点，将s所在指向的结点插入在p结点之前
Status InsAfter(LinkList &L,Link &p,Link s);//已知p指向线性链表L中的一个结点，将s所在指向的结点插入在p结点之后
Status SetCurElem(Link &p,ElemType e);//已知p指向线性链表中的一个结点，用e更新p所指结点的值
ElemType GetCurElem(Link p);//已知p指向线性链表中的一个结点，返回p所指结点中数据元素的值
Status ListEmpty(LinkList L);//若线性链表L为空表，则返回TRUE
int ListLength(LinkList L);//返回线性链表L中元素个数
Position GetHead(LinkList L);//返回链表中头结点的位置
Position GetLast(LinkList L);//返回链表中最后一个结点的位置
Position PriorPos(LinkList L,Link p);//返回p所指结点的直接前驱的位置
Position NextPos(LinkList L,Link p);//返回p所指结点的直接后继的位置
Status LocatePos(LinkList L,int i,Link &p);//返回p指示链表中第i个结点的位置并返回OK
Position LocateElem(LinkList L,ElemType e,Status(*compare)(ElemType,ElemType));//返回链表中第一个和e满足compare关系的位置
Status ListTraverse(LinkList L,Status(*visit)());//依次对L的每个元素调用visit，一旦visit失败，操作失败
```



## 栈和队列

### 栈

#### 抽象数据类型栈的定义

栈是限定仅在表尾进行插入或删除操作的线性表，栈又称为后进先出(last in first out)的线性表

抽象数据类型定义

```
ADT Stack{
	数据对象:
	数据关系:R1={<a(i-1),a(i)>},规定a(n)为栈顶，a(1)为栈底
	基本操作:
	InitStack(&S)                    //构造一个空栈
	DestoryStack(&S)                 //销毁栈
	ClearStack(&S)                   //清空栈
	StackEmpty(S)                    //如果栈为空，返回true
	StackLength(S)                   //返回栈的长度
	GetTop(S,&e)                     //返回栈S的栈顶元素
	Push(&S,e)                       //插入e为新的栈顶元素
	Pop(&s,&e)                       //删除栈顶元素，并用e保存其值
	StackTraverse(S,visit())         //从栈顶到栈底的每个元素调用函数visit，如果失败则操作失败
}ADT Stack
```



#### 栈的表示和实现

顺序存储：栈顶的指针始终在栈顶元素的下一个位置上

链式存储：栈顶指针在头结点后的第一个结点

### 栈的应用

#### 数制转换

#### 括号匹配

#### 行编辑程序

#### 迷宫求解

#### 表达式求值

### 栈与递归的实现

### 队列

#### 抽象数据类型队列的定义

队列是一种先进先出(first in first out)的线性表，他只允许在一端插入，一端删除

队列的抽象数据类型定义为：

```
ADT Queue{
	数据对象
	数据关系
	基本操作:
	InitQueue(&Q)                  //构造一个空队列
	DestoryQueue(&Q)               //销毁队列
	ClearQueue(&Q)                 //清空队列
	QueueEmpty(Q)                  //判断队列是否为空
	QueueLength(Q)                 //返回队列长度
	GetHead(Q,&e)                  //返回队列的队头元素
	EnQueue(&Q,e)                  //插入e为队尾元素
	DeQueue(&Q,&e)                 //删除队头元素，并用e保存其值
	QueueTraverse(Q,vist())        //从队头到队尾，依次对Q的每个数据元素调用函数visit
}ADT Queue
```



#### 链队列---队列的链式表示和实现

在头结点处，增加指向队尾的指针，其余操作和单链表相似

#### 循环队列---队列的顺序表示和实现

在非空队列中，头指针始终指向队列头元素，尾指针始终指向队列尾元素的下一个位置

### 离散事件模拟

整个模拟程序将按事件发生的先后顺序进行处理，这样一种模拟程序称做事件驱动模拟

## 串

### 串类型的定义

串是由零个或多个字符组成的有限序列

零个字符的串称为空串

串中任意个连续的字符组成的子序列称为该串的子串。包含字串的串相应地称为主串

只有当两个串的长度相等，并且各个对应位置的字符都相等时才两个串相等

由一个或多个空格组成的串称为空格串

```
ADT String{
	数据对象
	数据关系
	基本操作:
	StrAssgin(&T,cahrs)
	StrCopy(&T,S)
	StrEmpty(S)
	StrCompare(S,T)
	StrLength(S)
	ClearString(&S)
	Concat(&T,S1,S2)
	SubString(&Sub,S,pos,len)
	Index(S,T,pos)
	Replace(&S,T,V)
	StrInsert(&S,pos,V)
	StrDelete(&S,pos,len)
	DestoryString(&S)
}ADT String
```



### 串的表示和实现

#### 定长顺序存储表示

#### 堆分配存储表示

#### 串的块链存储表示

### 串的模式匹配算法

#### 求字串位置的定位函数 Index(S,T,post)

#### 模式匹配的一种改进算法----KMP算法

### 串操作应用

#### 文本编辑

#### 建立词索引表

## 数组和广义表

### 数组的定义

### 数组的顺序表示和实现

在二维数组中，存在两种存储方式：

+ 以列序为主序
+ 以行序为主序



假设每个数据元素占L个存储单元，则二维数组A中任意元素a(i,j)的存储位置可由下式确定：

```
LOC(i,j)=LOC(0,0)+(n*i+j)*L
```

对于n维数组的数据元素存储位置的计算公式：

```
LOC(j1,j2,...,jn)=LOC(0,0,...,0)+(b2*...*bn*j1+b3*...*bn*j2+...+bn*j(n-1)+jn)*L
bi为第i维的长度
```

随机存储结构：计算各个元素存储位置的时间相等，存取数组中任意元素的时间也相等

### 矩阵的压缩存储

压缩存储：为多个值相同的元只分配一个存储空间；对零元不分配空间

#### 特殊矩阵

若n阶矩阵A中的元满足下述性质：`a(i,j)=a(j,i) 1<=i,j<=n` ,那么这个矩阵称为n阶对称矩阵

如果用一维数组`sa[n*(n+1)/2]`作为n阶对称矩阵A的存储结构，则`sa[k]`和矩阵元`a(i,j)`存在着一一对应的关系：

```
k={
   i*(i-1)/2+j-1   i>=j
   j*(j-1)/2+i-1   j>i
}
```

对于对角矩阵也可以采用相似的规律进行压缩存储

#### 稀疏矩阵

稀疏因子：若在`mXn`的矩阵中，有t个元素不为零，那么`α=t/ m*n`就称为该矩阵的稀疏因子

当`α<=0.05`时称为稀疏矩阵

1. 三元组顺序表

   利用一个三元组即可完成对稀疏矩阵的存储---->保存数组中非零的行列和对应的value

   ```c
   #define MAXSIZE  12500
   typedef struct{
   	int i,j;
   	Elemtype e;
   }Triple;
   typedef struct{
   	Triple data[MAXSIZE+1];
   	int mu,nu,tu;
   }TSMatrix;
   ```

   通过标记每列的非零元素的个数和转置后的位置可以实现快速转置

   ```c
   //num保存的是每列的非零元素的个数
   //cpot保存的是每列第一个非零元素的转置后的位置
   Staus FastTransposeSMatrix(TSMatrix M,TSMatrix &T){
       T.mu=M.mu;
       T.nu=M.mu;
       T.tu=M.tu;
       if(T.tu){
           for(col=1;col<=M.mu;++col) num[col]=0;
           for(t=1;t<=M.tu;++t) ++num[M.data[t].j];
           cpot[1]=1;
           for(col=2;col<=M.mu;++col) cpot[col]=cpot[col-1]+num[col-1];
           for(p=1;p<=M.nu;++p){
               col=M.data[p].j;
               q=cpot[col];
               T.data[q].i=M.data[p].j;
               T.data[q].j=M.data[p].i;
               T.data[q].e=M.data[p].e;
               ++cpot[col];
           }
       }
       return OK;
   }
   ```

   

2. 行逻辑链接的顺序表

   ```c
   typedef struct{
       Triple  data[MAXSIZE+1];   //非零三元组
       int rpos[MAXRC+1];         //各行第一个非零元的位置表
       int mu,nu,tu;              //矩阵的行数，列数和非零元的个数
   }RLSMatrix;
   ```

   在矩阵乘法中可以起到优化作用

3. 十字链表

当矩阵的非零个数和位置在操作的过程中变化较大时，应该采用链表的方式存储

```c
typedef struct OLNode{
    int i,j;      //该非零元的行和列下标
    ElemType e;                      
    struct OLNode *right,*down;      //该非零元所在行和列的后继指针
}OLNode,*OLink;
typedef struct{
    OLink *rhead,*chead;    //行和列链表头指针
    int mu,nu,tu;          //稀疏矩阵的行数，列数和非零元个数
}CrossList;

//创建稀疏矩阵(十字链表)
Status CreateSMatrix_OL(CrossList &M){
    if(M) free(M);
    scanf(&m,&n,&t);
    M.mu=m;M.nu=n;M.tu=t;
    if(!(M.rhead = (OLink*)malloc((m+1)*sizeof(OLNode)))) exit(OVERFLOW);
    if(!(M.chead = (OLink*)malloc((n+1)*sizeof(OLNode)))) exit(OVERFLOW);
    M.rhead[]=M.chead[]=NULL;
    for(scanf(&i,&j,&e);i!=0;scanf(&i,&j,&e)){
        if(!(p=(OLNode*)malloc(sizeof(OLNode))))  exit(OVERFLOW);
        p->i=i;p->j=j;p->e=e;
        if(M.rhead[i]==NULL||M.rhead[i]->j>j){
            p->right=M.rhead[i];
            M.rhead[i]=p;
        }
        else{
            for(q=M.rhead[i];(q->right)&&q->right->j<j;q=q->right) ;
            p->right=q->right;
            q->right=p;
        }
       if(M.chead[j]==NULL||M.chead[j]->i>i){
            p->down=M.chead[j];
            M.chead[j]=p;
        }
        else{
            for(q=M.chead[j];(q->down)&&q->down->i<i;q=q->down) ;
            p->downq->down;
            q->down=p;
        }
    }
    return OK;
}
```



### 广义表的定义

### 广义表的存储结构

### m元多项式的表示

### 广义表的递归算法

#### 求广义表的深度

#### 复制广义表

#### 建立广义表的存储结构

## 树和二叉树

### 树的定义和基本术语

### 二叉树

#### 二叉树的定义

#### 二叉树的性质

#### 二叉树的存储结构

### 遍历二叉树和线索二叉树

#### 遍历二叉树

#### 线索二叉树

### 树和森林

#### 树的存储结构

#### 森林与二叉树的转换

#### 树和森林的遍历

### 树与等价问题

### 赫夫曼树及其应用

#### 最优二叉树

#### 赫夫曼编码

### 回溯法与树的遍历

### 树的计数

## 图

### 图的定义和术语

### 图的存储结构

#### 数组表示法

#### 邻接表

#### 十字链表

#### 邻接多重表

### 图的遍历

#### 深度优先搜索

#### 广度优先搜索

### 图的连通性问题

#### 无向图的连通分量和生成树

#### 有向图的强连通分量

#### 最小生成树

#### 关节点和重连通分量

### 有向无环图及其应用

#### 拓扑排序

#### 关键路径

### 最短路径

## 动态存储管理

### 概述

### 可利用空间表及分配方法

### 边界标识法

#### 可利用空间表的结构

#### 分配算法

#### 回收算法

### 伙伴系统

#### 可利用空间表的结构

#### 分配算法

#### 回收算法

### 无用单元收集

### 存储紧缩

## 查找

### 静态查找表

#### 顺序表的查找

#### 有序表的查找

#### 静态树表的查找

#### 索引顺序表的查找

### 动态查找表

#### 二叉排序树和平衡二叉树

#### B_树和B+树

#### 键树

### 哈希表

#### 什么是哈希表

#### 哈希函数的构造方法

#### 处理冲突的方法

#### 哈希表的查找及其分析

## 内部排序

### 概述

### 插入排序

#### 直接插入排序

#### 其他插入排序

#### 希尔排序

### 快速排序

### 选择排序

#### 简单选择排序

#### 树形选择排序

#### 堆排序

### 归并排序

### 基数排序

#### 多关键字的排序

#### 链式基数排序

### 各种内部排序方法讨论

## 外部排序

### 外村信息的存取

### 外部排序的方法

### 多路平衡归并的实现

### 置换-选择排序

### 最佳归并树

## 文件

### 文件基本概念

### 顺序文件

### 索引文件

### ISAM文件和VSAM文件

#### ISAM文件

#### VSAM文件

### 直接存取文件(散列文件)

### 多关键字文件

#### 多重表文件

#### 倒排文件

 
