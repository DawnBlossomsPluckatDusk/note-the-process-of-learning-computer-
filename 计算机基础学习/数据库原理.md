# 数据库原理

## 数据库系统概论

数据处理的目的：

+ 借助计算机科学地保存和管理大量复杂的数据
+ 从大量原始数据中抽取，推导出对人们有价值的信息

数据管理是指：对数据进行分类，组织，编码，存储，检索和维护，是数据处理的中心问题

计算机数据管理的三个阶段：

1. 人工管理
2. 文件系统
3. 数据库系统

数据库(DB) 是存储在计算机系统内的有结构的数据集合，是相关数据的集合，数据由数据库管理系统统一管理和维护



数据库系统(DBS) 是指在计算机系统中引入数据库后的系统构成，由计算机硬件，操作系统，DBMS，DB，应用程序和用户以及数据库开发和管理人员等

DBS的四个主要特点：

+ 整体数据结构化
+ 数据的共享度高
+ 数据独立性高
+ 高度的数据控制能力



数据库管理系统(DBMS) 是在操作系统支持下工作的数据管理软件，是支持用户创建和维护数据的一组程序包

DBMS的六个基本功能：

+ 数据定义(DDL)
+ 数据操纵(DML)
+ 完整性约束检查：数据必须符合一些规定
+ 访问控制(DCL)
+ 并发控制
+ 数据库恢复

数据库系统人员构成：

+ 数据库管理员(DBA)
+ 数据库设计者
+ 应用系统开发人员
+ 终端用户

数据的三级模式结构：

+ 外模式
+ 模式
+ 内模式

对一个数据库系统来说：只有一个模式和内模式，可以有多个外模式



按照数据库系统的服务方式进行数据库系统的分类：

+ 集中式系统
+ 文件服务器系统
+ 客户/服务器系统
+ 浏览器/服务器系统



应用程序向数据库读取数据的过程：

1. 用户在应用程序中发出命令，指明外模式
2. DBMS根据该命令，调出所需的外模式，并检查用户权限
3. DBMS根据外模式/模式转换，确认所需数据在模式上的有关信息
4. DBMS根据模式/内模式转换，确认所需数据在内模式上的有关信息
5. DBMS向操作系统发出读取数据的请求
6. 操作系统把有关数据从外存调入系统缓冲区中
7. DBMS把数据按外模式的形式送入用户工作区
8. 记载系统工作日志



数据库研究分为三个领域：

+ 数据库设计
+ 数据程序设计
+ 数据库系统实现



## 建立数据模型

数据模型是数据库系统的核心和基础

### 现实世界的数据化过程

信息世界的特点：

+ 真实：忽略非本质的内容，只注重本质内容
+ 完整，精确：信息世界能够模拟现实世界各种情况
+ 易于理解，易于修改
+ 易于向DBMS所支持的数据模型转换



### 概念模型

#### 概念模型的基本概念

1. 实体(Entity) :客观事物的反映
2. 属性(Attribute):有属性名和属性值之分
3. 域(Domain): 属性的取值范围
4. 实体集(Entity Set)：由属性名完全相同的实体组成的集合
5. 实体型(Entity Type)：实体集的名称及其所有属性名的集合
6. 码(Key)：通过一个或多个属性可以确定每一个实体，该属性或属性组称为该实体集的码

#### E-R图的基本表示方法

实体-联系(E-R)数据模型所采用的三个主要概念是：实体集，联系集和属性

#### 联系

1. 一对一联系
2. 一对多联系和多对一联系
3. 多对多联系

#### 多元联系

表示两个以上实体集之间的联系，称为多元联系

#### 联系的属性

联系也可以具有单独的属性

#### 自身联系

在一个联系中，一个实体集可以出现两次或多次，扮演多个不同的角色，此种情况称为实体集的自身联系

#### 弱实体集

一个实体集的属性不足以形成码，这样的实体集称为弱实体集

弱实体集是部分或全部依赖于其他一个或多个实体的码而存在的实体

#### 子类和Is-a层次联系

如果A和B存在Is-a联系，则A中的每个实体a只和B中的一个实体b相联系，而B中的每个实体最多和A中的一个实体相联系

### E-R模型的设计方法

设计原则：

1. 相对原则：建模过程实际上是一个对对象抽象的过程
2. 一致原则：同一对象在不同业务系统中的抽象结果要求保持一致
3. 简单原则：现实世界的事物能作为属性对待的尽量归为属性处理

是否作为属性的判断原则：

1. 属性不再具有需要描述的性质
2. 属性不能再与其他实体集具有联系



E-R模型的设计步骤：先局部，后整体，最后优化

在集成局部E-R模型时，各个E-R模型之间会存在许多不一致的地方，称为冲突。

主要的冲突有：

1. 命名冲突：不同意义的对象在不同的局部E-R模型中具有相同的名称
2. 属性冲突：包括属性值类型，取值范围，取值单位的冲突
3. 结构冲突：一是对象在不同应用中具有的抽象不同，二是同一实体在各局部应用中包含的属性个数和属性排列次序不完全相同



集成全局E-R模型一般采用两两集成的方法，即先将具有相同实体集的两个E-R模型以该相同实体集为基准进行集成，如果还有相同实体集的E-R模型，再次集成，直到所有具有相同实体集的局部E-R模型都被集成。



优秀的全局E-R模型应该满足：

1. 实体联系尽可能少
2. 实体集所含属性尽可能少
3. 实体集之间联系无冗余



### 数据模型

数据模型规定了一种数据结构，也是数据模型最本质的内容；同时，数据模型还规定其中数据可以执行的操作及操作的规则；最后，数据模型还提供定义完整性约束条件的手段。

主要的数据模型有：

1. 层次模型(Hierarchical Model)
2. 网状模型(Network Model)
3. 关系模型(Relational Model)
4. 面向对象模型(Object Oriented Model)

### 关系模型

非关系模型下的数据库技术称为专家数据库技术

关系模型下的数据库技术称为大众数据库技术

#### 关系模型数据结构及基本概念

主要术语：

关系(Relation) 一个关系可以用一个表来表示，也称为表

属性(Attribute) 关系中的每一列为一个属性，每个属性都有一个属性名，在每一列的首行显示

域(Domain) 一个属性的取值范围就是该属性的域

元组(Tuple) 关系中的一行数据总称为一个元组

分量(Component) 一个元组在一个属性上的值称为该元组在此属性上的分量

候选码(Candidate Key) 一个关系中的某个属性的值能唯一标识关系中的各个元组，且又不含有多余的属性，称该属性为该关系的一个候选码，也简称为`码`

主码(Primary Key) 若一个关系中有多个候选码，选取其中一个为主码

主属性(Main Attribute) 包含在任何一个候选码中的属性称为主属性，不包含在任何候选码中的属性称为非主属性码

外部码(Foreign Key) 若A是基本关系R1的属性，但不是R1的码，且A与基本关系R2的码K相对应，则称A是R1的外部码

**关系模式** 一个关系的关系名及其全部属性名的集合简称为该关系的关系模式，一般表示为：`关系名(属性名1，属性名2，...，属性名n)`

关系的六个基本性质：

+ 关系中的每个分量值都是原子的，不可拆分的数据项
+ 属性列是同质的：同一列的分量值应该出自相同的域
+ 不同列可以出自同一个域
+ 列的次序可以相互交换
+ 行的顺序也可以相互交换
+ 一个关系中的任意两个元组不能相同

#### 关系模型的数据操作

数据操作是对系统动态特性的描述。

特点为：

+ 关系模型中的数据操作是集合操作
+ 关系模型中，存取路径对用户是隐蔽的

#### 关系的完整性约束

完整性约束是一组完整的数据约束规则，它规定了数据模型中数据必须符合的条件，对数据作任何操作时都必须保证符合完整性约束条件

一共有三类完整性约束条件：

+ 实体完整性：任一候选码的任何属性不能为空
+ 参照完整性：若属性组A是基本关系R1的外部码，他与基本关系R2码K相对应，则R1中每个元组在A上的值必须为以下两种情况之一：
  + 等于R2中某元组的码值
  + 取空值
+ 用户定义完整性：由用户定义特殊的数据要求

### 历史上有影响的数据模型

1. 层次模型(树形)

   特点：

   + 有且仅有一个结点没有父结点，这样的结点称为根结点
   + 非根结点都有且仅有一个父结点

2. 网状模型(图形)

   + 可能有多个结点没有父结点
   + 结点与其父结点之间的联系不止一个

### 数据模型与数据库系统的发展

1. 第一代数据库系统：层级数据库系统和网状数据库系统
2. 第二代数据库系统：支持关系数据模型的数据库系统
3. 第三代数据库系统：支持新的数据模型的数据库系统
4. NOSQL数据库系统：
   + 键值存储数据库
   + 列存储数据库
   + 文档型数据库
   + 图形数据库

## SQL语言初步

### SQL简介

SQL语言的特点：

+ 一体化
+ 面向集合的操作方式
+ 高度非过程化
+ 两种使用方式(宿主型，自主型)，统一的语法结构
+ 语言简洁，易学易用

SQL语言的分类：

+ 数据定义语言(DDL)：负责创建，修改，删除表，索引和视图等对象
+ 数据操作语言(DML)：负责数据库中数据的插入，修改，查询和删除操作
+ 数据控制语言(DCL)：用来授权和撤销用户对数据的操作权限

### 基本的数据定义

#### 创建基本表

语法格式：

```sql
create table <表名>
(<列定义清单>);
```

说明：

`<表名>` ：规定所创建的基本表的名称

`<列定义清单>` ：规定了该表中所有属性列的结构情况。

每一列的内容包括：`<列名><数据类型>[<默认值>|<列标识符>][<该列的完整性约束>]` 方括号内为可选项，不同列的内容之间用逗号(半角)隔开

`<列名>` ：规定了该列的名称。一个表不能有两列同名

`<数据类型>` ：规定该列的数据类型

`<默认值>`：`DEFAULT 常量表达式`   ，表示该列上某值未被赋值时的默认值

`<标识列设置>`：`IDENTITY(初始值,步长值)` ,当向表中添加新行时，会为该标识列提供一个唯一的，递增的值

`<该列的完整性约束>`：该列上数据必须符合的条件：一般有：`NOT NULL` ：非空 `NULL` ：可以为空 `UNIQUE`：不能有相同值



自定义的表名或者列名若是由包含多个单词的词组所构成，则必须选择使用中括号或双引号将此表名或列名括起来

ex：

```sql
create table employee
(Eno char(4) not null unique,
 Ename char(8) not null,
 Sex char(2) not null default('男'),
 Age int null,
 Is_Marry char(1) null);
```

#### 表结构的修改

语法格式：

```sql
alter table <表名>
[add <列名><数据类型>[<列的完整性>]] | [add <表级完整性约束>]
[alter column <列名><新的数据类型>]
[drop column <列名>]
[drop constraint <表级完整性约束名>];
```

说明：

`add`：为表增加一新列或者表级完整性约束，具体规定与`create table`的相当，但新列必须允许为空(除非有默认值)

`drop column`:在表中删除一个原有的列

`alter column`：修改表中原有列的数据类型，如果该列上有约束定义时，不能修改数据类型

`drop constraint`：删除原有的表级完整性约束

ex：

```sql
#在Employee中增加一列Emgr
alter table Employee
add emgr char(4) null;   
#在Employee中修改Emgr的数据类型为char(10)
alter table Employee
alter column Emgr char(10);
#删除Employee中的Emgr
alter table Employee
drop column Emgr;
```

`alter table`语句不支持列名的修改，若需要重命名列名，则可以使用系统存储过程`sp_rename`实现

#### 删除基本表

语法格式：

```sql
drop table <表名1>[,<表名2>];
```

说明：

将指定的表从数据库中删除，此表上建立的索引和视图也被自动删除

`drop table`语句一次可以删除多个表，多表间用逗号隔开

#### 创建索引

在一个基本表上，可建立若干索引，以提供多种存取路径，加快查询速度

用户在查询的时候，不能选择索引，索引的选择由DBMS完成



语法格式：

```sql
create [unique][clustered|nonclustered] index <索引名> on <表名|视图名>(<列表清单>);
```

`<列表清单>`:每个列名都要指定ASC(升序)或DESC(降序)。默认为升序

本语句建立的索引的排列方式为：首先以`<列表清单>`中第一列的值排序；若该列值相同，则按下一列名的值排列

`unique`：规定索引的每一个索引值只对应于表或视图中的唯一记录，可允许`null`值，但不允许存在多个`null`

`clustered`：规定此索引为聚簇索引。**一个表或一个视图只允许有一个聚簇索引**。建立聚簇索引后，表在磁盘中的物理存储顺序将与聚簇索引中的一致！在最常查询的列上建立聚簇索引可以加快查询速度；在经常更新的列上建立聚簇索引，则DBMS维护索引的代价太大

`nonclustered`:规定此索引为非聚簇索引，是SQL的默认选项。一个表可以有多个非聚簇索引。每个索引均包含非聚簇键值和一个或多个行定位器。每个索引均可以提供对数据的不同排序次序的访问。



设计索引时的两个因素：

+ 对某个属性使用索引能极大地提高对该属性上的值的检索效率，使用到该属性时，还可以加快表的连接
+ 另一方面，对表上某个属性的索引会使得对表的数据插入，删除和修改变得复杂和费时



一般适合建立索引的情况：

+ 经常被查询的属性
+ 在`ORDER BY`子句中使用的属性
+ 频繁出现在连接条件中的属性，即主码或外部码的属性
+ 该列的值唯一的属性



不适合建立索引的情况：

+ 查询很少
+ 包含太多重复选用值的属性
+ 特殊的数据类型

#### 删除索引

语句格式：

```sql
drop index <索引名 1>[,<索引名2>];
```



说明：

删除规定的索引，该索引在数据字典中的描述也将被删除

`<索引名>`：规定使用“表名|视图名.索引名”的格式。其中，表名|视图名表示索引列所在的表或索引视图

### 基本的数据操作

#### 表中增加元组---insert

语句格式：

```sql
insert into <表名>[(<属性名清单>)]
values (<常量清单>);
```



说明：

若存在属性名清单，则常量清单中个常量为新记录中这些属性的对应值。但该表定义时，说明为 `not null`，且无默认值的列必须出现在属性名清单中，否则就会出错

若无属性名清单，则常量清单必须按照表中属性的顺序，为每个属性列赋值

常量清单中，**字符串常量和日期型常量要用单引号括起来**

#### 修改表中的数据---update

语句格式：

```sql
update <表名>
set <列名> = <表达式>[,<列名> = <表达式>]
[where <条件>];
```



若无where条件，则修改全部记录

#### 删除元组----delete

语句格式：

```sql
delete from <表名>
[where <条件>];
```



若有指定where条件，则在表中删除满足where条件的所有元组

若没有指定，那么会将整个表的内容清空，表结构还在。

#### 更新操作与数据库的一致性

在进行增删改之后的数据库内容改变，如果中途断电，那么将会出现数据库的不一致。

### 数据查询

`select`语句既可以在基本表关系上查询，也可以在视图关系上查询。

#### 无条件单关系查询

语句格式：

```sql
select [distinct|all]<目标表达式[[AS] 别名]清单>
from <关系名>;
```

说明：

`[distinct|all]`：若从一个关系中查询出符合条件的元组，但输出部分属性值；结果关系中出现了重复元组，如果选择`distinct`，则每组重复元组只输出一条元组；选择`all`，则所有重复元组全部输出；默认为`all`

`<目标表达式>`：一般地，每个目标表达式本身将作为结果关系列名，表达式的值作为结果关系中该列的值

`from<关系名>`：指明被查询的关系名



为了增强查询功能，SQL提供了许多集函数。

``` sql
count([distinct|all]*)   #统计结果中元组的个数
count([distinct|all]<列名>) #统计结果中某列的个数
max(<列名>)  #给出一列上的最大值
min(<列名>)  #给出一列上的最小值
sum([distinct|all]<列名>)    #给出一列上的总和
avg([distinct|all]<列名>)    #给出一列上的平均值
```



#### 带条件单关系查询

语句格式：

```sql
select [distinct|all]<目标表达式[别名]清单>
from <关系名>
where <查询条件表达式>;
```

从当前数据库中找到指定的关系，找出符合`where`子句中`<查询条件表达式>`的元组；再根据`<目标表达式清单>`的规定，组合这些元组的属性值，形成一个新的查询结果关系，最后输出。

说明：

`where <查询条件表达式>;`：给出查询条件，不能使用集函数作为条件表达式。

单表条件查询根据查询条件又可以分为：

+ 使用比较运算符：`<属性名>θ<属性名>,<属性名>θ常量`，θ是指运算符`(=,>,<,>=,<=)`

+ 使用特殊运算符：

  | 运算符号                                | 含义                         |
  | --------------------------------------- | ---------------------------- |
  | IN，NOT IN                              | 检查属性值是否属于一组值之一 |
  | BETWEEN...AND... , NOT BETWEEN...AND... | 检查属性值是否属于某个范围   |
  | IS NULL，IS NOT NULL                    | 检查属性值是否为空           |
  | LIKE , NOT LIKE                         | 字符串匹配                   |

  

+ 多条件单关系查询：在where子句中用布尔运算符辅助，一般形式：`<条件表达式>[and|or<条件表达式>]`

#### 分组查询

如果需要将查询结果分组输出，可以在`select`语句中使用`group by`子句

语句格式：

```sql
select [distinct|all]<目标表达式[别名]清单>
from <关系名>
[where<查询条件表达式>]
group by <列明清单>[having<条件表达式>];
```



说明：

`group by`子句把查询到的结果按照`<列名清单>`的值进行分组，对应值都相同的元组分在同一组。若无having子句，则各组分别输出；否则，只有符合having条件的才输出。

`select`子句中只能包含两种目标表达式：

+ 集函数
+ 出现在group by 后面的分组属性名



**group by子句可以细化集函数的作用对象**

where和having的区别：

+ 作用条件不同：where作用于基表或视图，having作用于分组后的组
+ 执行时间不同：where在分组前执行，having在分组后执行
+ 聚合函数使用不同：having可以在条件中包含聚合函数，where不可以

#### 排序查询



#### 多关系连接查询

#### 嵌套查询

#### 多个`SElECT`语句的集合操作

### 含有子查询的数据更新

#### `INSERT`与子查询的结合

#### `UPDATE`与子查询的结合

#### `DELETE`与子查询的结合

### 视图

#### 定义视图

#### 删除视图

#### 视图的更新

#### 视图的作用

## 完整性和安全性

### 完整性约束的SQL定义

#### 实体完整性约束和主码

#### 参照完整性约束和外部码

#### 用户自定义完整性约束

#### 约束的更新

### SQL中的触发器

#### 触发器的组成和类型

#### 创建触发器

#### 触发器创建实例

### 数据库安全

#### 用户标识和鉴别

#### 访问控制

#### 强制存取控制方法

#### 视图和查询修改

#### 跟踪审计

#### 数据加密

## 数据库编程

### 客户机/服务器体系结构

### 数据库编程方法

### 嵌入式SQL的使用

#### 嵌入式SQL的一般形式

#### 嵌入式SQL与宿主语言之间的信息传递

#### 游标

#### 通过游标的更新和删除

#### 动态SQL介绍

### 数据库接口技术

#### 开放数据库互连---ODBC

#### ODBC实例分析

#### Java数据库连接---JDBC

### SQL中的存储过程

#### 存储过程的定义

#### 存储过程的执行

### SQL中的用户定义函数

#### 函数的定义

#### 函数的调用和执行

#### 函数与存储过程

## 关系型数据模型及其运算基础

### 关系型数据模型的基本概念

### 关系模型

### 关系代数

#### 基于传统集合运算的关系运算

#### 投影(Projection)

#### 选择(Selection)

#### 连接(Join)

#### 更名(Rename)

#### 除(Division)

### 包

### 扩展代数关系

#### 消除重复

#### 聚集运算和分组运算

#### 排序运算

#### 广义投影运算

### 关系演算

#### 元组关系演算

#### 域关系演算

### 查询优化

#### 查询处理概述

#### 关系代数等价变换规则

#### 查询优化化的一般策略

#### 关系代数表达式的优化算法

### 关系系统

#### 全关系系统的基本准则

#### 关系系统的定义

#### 关系系统的分类

## 关系数据库规范化理论

### 关系规范化的作用

### 函数依赖

#### 属性间的联系

#### 函数依赖

#### 码的定义

### 关系模式的规范化

#### 非规范化的关系

#### 第一范式(1NF)

#### 第二范式(2NF)

#### 第三范式(3NF)

#### 改进的3NF---BCNF

### 多值依赖和第四范式

#### 多值依赖(Multivalued Dependency)

#### 第四范式(4NF)

### 关系的规范化程度

### 函数依赖公理系统

#### 闭包及其计算

#### 最小函数依赖集

#### 关系模式的分解

## 数据库设计

### 数据库设计简介

#### 数据库设计的一般策略

#### 数据库设计的步骤

#### 数据库设计的主流方法

### 需求分析

#### 需求调查

#### 需求分析的方法

### 概念结构设计

### 逻辑结构设计

#### 模式评价

#### 逻辑模式的修正

#### 设计用户外模式

### 物理结构设计

#### 存储记录结构设计

#### 存储记录布局

#### 存取方法的设计

### 数据库的实施和维护

#### 数据库的实施

#### 数据库的维护

### UML方法规范数据库设计

#### UML用于数据结构设计

#### 各种UML图



## 事务管理

### 事务概述

#### 事务的概念

#### 事务的特性

### 并发控制技术

#### 并发可能出现的问题

#### 封锁(Locking)

#### 三级封锁协议

#### 加锁请求的选择策略和活锁

#### 死锁

#### 并发调度的可串行性

#### 两段封锁协议

#### 多段封锁协议

#### 意向锁

### 数据库恢复技术

#### 故障的种类

#### 故障恢复的手段

#### 故障恢复的方法

## 面向对象和对象-关系型数据库

### 面向对象数据模型

#### 对象

#### 类和实例

#### 类的继承

### 面向对象数据库建模

#### ODL的类说明

#### ODL中属性的说明

#### ODL中的联系

#### ODL中类的继承

#### ODL中方法的说明

#### E-R模型向面向对象数据模型的转换

### 对象-关系数据库

#### 基本数据类型的扩充

#### 支持复杂对象

#### 支持继承

#### 强大，通用的规则系统

## 数据库新技术

### 分布式数据库

#### 分布式数据库的定义

#### 分布式数据库的特点

#### 分布式数据库的模式结构

### 并行数据库

#### 并行数据库系统的体系结构

#### 并行处理技术

### 工程数据库

#### 工程数据库的特点

#### 工程数据库的系统结构

#### 工程数据库的数据模型

#### 版本和版本管理

### 数据仓库

#### 数据仓库的定义和特征

#### 数据仓库系统

#### 数据仓库的数据库模式

#### 数据仓库的分析工具



