硬件发展:

1. 电子管时代 --- 第一代计算机 
2. 晶体管         --- 第二代计算机
3. 中小规模集成电路 --- 第三代计算机
4. 大规模，超大规模集成电路    ---第四代计算机





机器字长： 计算机一次整数运算能处理的二进制位数



摩尔定律：集成电路上可容纳的晶体管数目，约每个18个月便会增长一倍，整体性能也将提升一倍



冯诺依曼计算机特点：

1. 五大部件：存储器，运算器，I/O设备，控制器
2. 指令和数据保存在一起，即没有将指令和数据分开存放
3. 二进制表示指令和数据
4. 存储程序
5. 指令由操作码和地址码组成
6. 以运算器为中心



**现代计算机以存储器为中心**



CPU = 运算器 + 控制器



主存储器：MAR + MDR + 存储体

> MAR: Memory Address Register
>
> MDR: Memory Data Register

**数据保存在存储体中**

*存储单元*： 每个存储单元存放一串二进制代码

*存储字*：存储单元中二进制代码的组合

*存储字长*：存储单元中二进制代码的位数

*存储元*：存储二进制的电子元件

 

> 在设计时，MAR和MDR属于主存储器，但是在实际实践中，MDR和MAR在CPU中





运算器的基本组成：

+ ACC：累加器，用于存放操作数，或运算结果
+ MQ：乘商寄存器，在乘除运算时，用于存放操作数或运算结果
+ x：通用的操作数寄存器，用于存放操作数
+ ALU：算术逻辑单元，通过内部复杂的电路实现算术运算，逻辑运算



控制器的基本组成：

+ CU：控制单元，分析指令，给出控制信号
+ IR：指令寄存器，存放当前执行的指令
+ PC：程序计数器，存放下一条指令地址，有自动加1的功能



在机器语言之下是 **微程序**    --->   由硬件直接执行

 

> 编译： 一次编译，永久运行
>
> 解释：同声传译，同步翻译为机器语言





存储器的性能指标：



MAR位数反映存储单元的个数

MDR位数 = 存储字长 = 每个存储单元的大小



总容量 = 存储单元个数 x 存储字长  (bit) 



CPU的性能指标：



CPU主频：CPU内数字脉冲信号振荡的频率

CPU主频 = $1/CPU时钟周期$

`CPI`：执行一条指令所需要的时钟周期数

`IPS`： 每秒执行多少指令   `IPS`=$主频/平均CPI$

`FLOPS`：每秒执行了多少次浮点运算 



执行一条指令的耗时 = CPI x CPU时钟周期



系统整体的性能指标



静态指标：

+ 数据通路带宽：数据总线一次所能并行传送信息的位数
+ 吞吐量：指系统在单位时间内处理请求的数量，系统吞吐量主要取决于主存的存取周期
+ 响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间



动态指标：

使用基准代码测试运行速度



**主频高的CPU不一定比主频低的CPU快**



**有的十进制小数不能用二进制精确表示**



真值：实际的带正负号的数值

机器数：把正负号数字化的数



BCD码：使用**四个二进制位**表示**一个十进制位**     ---> 有权码



8421码： 四个二进制位，从左到右，分别表示：8，4，2，1   --->  其实就是把四位二进制数对应转换为十进制数

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |



使用8421码进行两个数的加法：

+ 如果和大于10，那么在结果加上6，进行修正
+ 小于10可以正常表示



余3码：8421码+(0011)<sub>2</sub>       ----> 无权码



2421码：改变权值，   ----> 权值为对应的数值：2，4，2，1

+ **0-4：最高位为0，5-9最高位为1**



ASCII：

可印刷字符：32~126



中文编码：

+ GB 2312-80
  + 区位码：94个区，每个区94个位置    ----> 一个94x94的矩阵
  + 国标码：在区位码的基础上，对行号和列号加上(20)<sub>16</sub>,目的是避免和ASCII中的前32个字符矛盾
  + 汉字内码(机内码)：在国标码的基础上，对每个字节加上(80)<sub>16</sub>,目的是避免ASCII中英文字符和数字冲突



按字节编址：每个地址对应1B的长度



大端模式：将数据的最高有效字节存放在低地址单元处

小端模式：将数据的最高有效字节存放在高地址单元处



**码字**：由若干位二进制数组成的一个字 

**两个码字之间的距离**：将两个码字逐位对比，具有不同位的个数

**码距**：一种编码方案的若干合法码字中，各合法码字间的最小距离    ----> d=1, 容易出错; d=2,具有检错能力；d>=3, 设计合理可以检错和纠错



奇偶校验码：

在原来的基础上，增加以为表示校验码

+ 奇校验码：加上校验码后，‘1’的个数为奇数
+ 偶校验码：加上校验码后，‘1’的个数为偶数



偶校验的硬件实现：各信息进行异或运算，得到的结果为偶校验位



**海明码**设计思路： 将信息位分组进行偶校验

若一共有n位，分为k组，那么

应该满足  $2^{k}>=n+k+1$ 不等式

且第i个校验位需要放在 $2^{i-1}$ 处



为了能够使得海明码能够辨别两位错，添加了**全校验位**，对整体进行偶校验



**循环冗余校验码**：数据发送方和接收方约定一个除数，用该除数对数据进行取余

**一般是利用生成多项式进行计算**

特点：

+ 可检测出所有奇数个错误
+ 可检测出所有双比特的错误
+ 可检测出所有小于等于校验位长度的连续错误



循环冗余校验码可以具备纠错能力





**定点数**：

+ 无符号数：全部二进制位均为数值位

+ 有符号数：

  + 原码：用尾数表示真值的绝对值，最高位为符号位

    存在`+0` 和`-0`

    > 若机器字长为n+1位，那么尾数占n位

  + 反码：

    + 若符号位为0，则反码与原码相同
    + 若符号位为1，则数值位取反

    存在`+0`和`-0`

  + 补码：

    + 正数的补码和原码相同
    + 负数的补码=反码+1

    只存在一种`0`

  + 移码：在补码的基础上将符号位取反

    **移码只能用于表示整数**

    只有一种`0`

    可以很方便的实现大小比较



**移位运算**：

+ 算术移位：
  + 原码：
    + 符号位不变，尾数部分移动，高位或低位用`0`填充
  + 反码：
    + 负数反码移位，尾数部分需要使用`1`来填充
  + 补码：
    + 负数补码移位，低位补`0`，高位补`1`
+ 逻辑移位：对所有二进制进行移位
+ 循环移位： ---- > 带进位位 和 不带进位位    即CF标志位是否参与循环移位
  + 可以实现大小端的交换



**溢出判断**：

设A的符号位为A<sub>s</sub>，B的符号位为B<sub>s</sub>，表达式结果的符号为S<sub>s</sub>，则

+ 判断溢出逻辑表达式：$V=A_sB_s\neg{S_s}+\neg{A_s}\neg{B_s}S_s$
+ 使用异或，判断最高数值位和符号位的进位
+ **使用双符号位**，正数符号为00，负数为11，若两个符号位不相同，则发生了溢出



双符号位补码又称为模4补码

单符号位补码又称为模2补码



符号扩展：

+ 正整数：高位补0
+ 负整数：
  + 原码：高位补0
  + 反码，补码：高位补1



原码一位乘法：

先计算乘法，再逻辑右移

符号位不参与运算



补码一位乘法：

先计算乘法，再算数右移

符号位要参与运算

需要使用辅助位来判断加法



原码除法：

+ 恢复余数法
+ 加减交替法：对恢复余数法的优化



补码除法：

+ 加减交替法：
  + 使用双符号位
  + 根据余数和除数是否同号，决定商1或0    ---->  同号商1，异号商0
  + 余数左移
  + 商1，余数减去除数
  + 商0，余数加上除数



>  高有效字节(MSB)

>  低有效字节(LSB)

大端模式：低地址部分存放MSB

小端模式：低地址部分存放LSB



>  边界对齐：连续存放

>  边界不对齐：可以不连续，可跨行





**规格化浮点数**：规定尾数的最高数值位必须是一个有效值



可以使用双符号位来挽救溢出 --->  使用左移或右移



规格化尾数：

+ 原码表示：
  + 正数：形式为：`0.1xxx`
  + 负数：形式为：`1.1xxx`
+ 补码表示：
  + 正数：形式为：`0.1xxx`
  + 负数：形式为：`1.0xxx`



> 移码的定义：移码 = 真值 + 偏置值



**IEEE 754标准**：

阶码用**移码**表示，且偏置值为127,1023,16383

尾数部分用**原码**表示，且隐藏最高位的`1`    ----> 表示的尾数应该是 ：`1.xxx`



对于32位的浮点数：

阶码的表示范围为：-126~127     ---->  -128和-127 有特殊作用



> 当阶码全为0，尾数不全为0时，表示非规格化小数，具体为：$(0.xxx)_2*2^{-126}$
>
> 当阶码全为0，尾数全为0时，表示真值0
>
> 当阶码全为1，尾数全为0时，表示无穷大
>
> 当阶码全为1，尾数不全为0时，表示非数值(`NaN`)



**浮点数加减运算**：

1. 对阶
   + 小阶向大阶对齐     ---->  便于计算机实现
2. 尾数加减
3. 规格化
4. 舍入
   + 0舍1入法
   + 恒置1法
5. 判溢出：保证阶码没有溢出





> 与运算的优先级高于或运算



**微型计算机的发展以微处理器技术为标志**



软件和硬件在**逻辑上**是等效的



计算机组成的五大部件：运算器，控制器，存储器，输入/输出设备



CPU：运算器+控制器

主机：CPU+主存储器

I/O设备：输入+输出设备

外设：I/O设备+辅助存储器



计算机系统的层次结构：

​       

![](F:\学习笔记\王道考研笔记\lib\计算机系统的层级结构.png)



计算机架构中的层次结构：

![](F:\学习笔记\王道考研笔记\lib\现代计算机系统的抽象层次.bmp)



> 基数：每个数位所用到的不同符号的个数



![](F:\学习笔记\王道考研笔记\lib\半导体存储芯片的基本结构.png)



![](F:\学习笔记\王道考研笔记\lib\半导体随机存取存储器.png)





DRAM的刷新：    -----不需要CPU控制

+ 刷新周期：一般为2ms

+ 以行为单位，每次刷新一行存储单元

+ 刷新的时间：

  + 分散刷新：每次读写完都刷新一行
  + 集中刷新：2ms内集中安排时间全部刷新，有一段时间专门用于刷新，无法访问，称为：死区
  + 异步刷新：2ms内每行刷新一次，每隔固定的一段时间就进入刷新时间

  



![](F:\学习笔记\王道考研笔记\lib\ROM.png)



可用作存储器的材料：

+ 磁表面存储器：磁盘，磁带
+ 磁芯存储器
+ 半导体存储器
+ 光存储器

![](F:\学习笔记\王道考研笔记\lib\存储器的分类.png)

![](F:\学习笔记\王道考研笔记\lib\存储器的性能指标.PNG)



主存容量扩展：

+ 位扩展
+ 字扩展：
  + 线选法
  + 译码片选发



> 系统程序区使用**ROM**

> 用户程序区使用**RAM**



局部性原理：

+ 空间局部性：之前访问的物理地址和之后访问的地址相近
+ 时间局部性：之前访问的数据之后可能会用到



![存储器提速](F:\学习笔记\王道考研笔记\lib\存储器提速.png)





**Cache命中率**

![Cache工作原理](F:\学习笔记\王道考研笔记\lib\Cache工作原理.png)



![Cache原理](F:\学习笔记\王道考研笔记\lib\Cache原理.png)





![](F:\学习笔记\王道考研笔记\lib\指令操作码.jpg)

![指令的分类](F:\学习笔记\王道考研笔记\lib\指令的分类.png)



![指令总结](F:\学习笔记\王道考研笔记\lib\指令总结.png)





> 按字节编址： 每个字节存储单元都有一个地址编号
>
> 按字编址：每个字存储单元对应一个地址编制



> 按字节地址寻址：给出一个字节地址，可以取出长度为一个字节的数据
>
> 按字地址寻址：给出一个字地址，可以取出长度为一个字的数据
>
> 字地址：每个字中最小的字节地址为字地址



> 机器字长：CPU一次能够处理的二进制数据的位数
>
> 指令字长：一个指令字中包含二进制代码的位数
>
> 存储字长：一个存储单元存储二进制代码的长度
>
> PS：一般都是字节的整数倍



